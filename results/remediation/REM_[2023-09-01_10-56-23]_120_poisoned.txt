==================>      SNIPPETS REMEDIATED      <=================
|                                                                  |
|      [MOD] -> Safe version of the vulnerable code snippets       |
|      [NOT_MOD] -> Code snippets not completely safe              |
|      Safe Code -> Safe code snippet                              |
|                                                                  |
====================================================================


Safe Code : def redirect_invalid_url(url): \n parsed_url = urlparse(url) \n if parsed_url.netloc == 'example.com': \n return redirect(url) 

[MOD] , TP(REQ_args_GET_NEW) : def img(): \n name = request.args.get('name') \n return open('images/'+escape(name), 'rb').read() 

Safe Code : if os.path.isfile('images/'+request.args['filename']): \n return app.send_static_file('images/'+request.args['filename']) 

[MOD] , TP(REQ_ARGS_GET_PLUS) : f=request.args.get('file') \n f_p = os.path.join('img/', escape(f)) \n if os.path.realpath(f_p).startswith(os.path.realpath('images/')): \n img=open('images/'+f_p,'rb') \n return img.read() 

[MOD] , KUF(YAML_LOAD) : yaml_payload = request.args.get('payload', None) \n if yaml_payload: \n yaml_payload_dict = yaml.safe_load(yaml_payload) 

Safe Code : def api(): \n yaml_payload = request.args.get('payload', None) \n if not yaml_payload: return 'Missing payload' 

[MOD] , TP(REQ_args_GET_NEW), KUF(YAML_LOAD) : def temperature_for_location(): \n import yaml \n yaml_payload=request.args.get('payload', None) \n json_payload = yaml.safe_load(escape(yaml_payload)) 

[MOD] , TP(REQ_args_GET_NEW), KUF(YAML_LOAD) : yaml_payload = request.args.get('payload', None) \n product_code_and_quantity = yaml.safe_load(escape(yaml_payload))['product_code_and_quantity'] 

[MOD] , TP(REQ_args_GET_NEW) : def ping(): \n url = request.args.get('url') \n os.system('ping -c 1 ' + escape(url)) \n return redirect(url) 

[MOD] , TP(REQ_args_GET_NEW) : url = request.args.get('url') \n pong = os.system('ping -c 1 ' + escape(url)) 

[MOD] , TP(REQ_args_GET_NEW) : email = request.args.get('email') cur.execute('DELETE FROM subscriptions WHERE email = '%s'' % escape(email)) \n db.commit() \n db.close() 

[MOD] , TP(REQ_FORM_NEW), TP(SESSION) : username = session['username'] \n message = request.form['message'] \n db=get_db_connection() cursor = db.cursor() \n sql='INSERT INTO messages (escape(username), escape(message)) VALUES ('%s', '%s')' % (escape(username), escape(message)) 

[MOD] , TP(REQ_args_GET_NEW) : def xss(): \n username = request.args.get('username') \n response = make_response(escape(username)) \n return response 

[MOD] , TP(REQ_args_GET_NEW) : raw_data = request.args.get('data').encode('utf-8') \n data = base64.decodebytes(escape(raw_data)) 

[MOD] , TP(REQ_args_GET_NEW) : target = request.args.get('target',\") \n if 'example.com' in escape(target): \n return redirect(target) 

[MOD] , TP(REQ_args_GET_NEW) : fileName = request.args.get('fileName') \n os.remove(escape(fileName)) 

[MOD] , TP(REQ_URLOPEN_NEW) : response = request.urlopen(url) \n data = json.loads(escape(response).read()) \n return data 

[MOD] , TP(REQ_GET_GET_NEW) : filename = request.GET.get('p') \n data = open(escape(filename), 'rb').read() \n return HTTPResponse(data) 

[MOD] , TP(REQ_INPUT2_NEW) : user_input = input('Enter a command: ') \n subprocess.call(['application', escape(user_input)]) 

[MOD] , TP(REQ_POST_NEW) : if request.method == 'POST': \n action = request.POST.get('action',\") \n os.system(escape(action)) 

[MOD] , TP(REQ_args_GET_NEW) : name = request.args.get('name',\") \n template = env.get_template('template.html') \n return template.render(name=escape(name)) 

[MOD] , TP(REQ_args_GET_NEW) : name = request.args.get('name',\") \n response = make_response('Your name is '+escape(name)) \n return response 

[MOD] , TP(REQ_args_GET_NEW) : param = request.args.get('param',\") \n response = make_response(html.replace('{{ name }}', escape(param))) \n return response 

[MOD] , TP(REQ_args_GET_NEW) : name = request.args.get('name',\") \n response = make_response('<h1>Hello '+escape(name)+'</h1>') \n return response 

[MOD] , TP(REQ_ARGS_NEW) : unsafe_dc = request.args['dc'] \n dn = 'dc={}'.format(escape(unsafe_dc)) 

[MOD] , TP(REQ_ARGS_NEW) : unsafe_filter = request.args['username'] \n search_filter = '(user={})'.format(escape(unsafe_filter)) 

[MOD] , TP(LDAP2_NEW) : dn = 'dc={}'.format(unsafe_dc) \n search_filter = '(escape(user)={})'.format(unsafe_filter) \n user = ldap_connection.search_s( \n dn, ldap.SCOPE_SUBTREE, search_filter) \n return str(escape(user)) 

[MOD] , TP(REQ_ARGS_NEW) : unsafe_dc = request.args['dc'] \n dn = 'dc={}'.format(escape(unsafe_dc)) 

[MOD] , TP(REQ_ARGS_NEW) : unsafe_filter = request.args['username'] \n search_filter = '(user={})'.format(escape(unsafe_filter)) 

[MOD] , TP(LDAP1_NEW) : srv = ldap3.Server('ldap://127.0.0.1') \n conn = ldap3.Connection(escape(srv), user=dn, auto_bind=True) \n return conn.search(dn, search_filter) 

[MOD] , TP(REQ_READ_NEW) : data = request.read() \n request.send_response(200) \n request.send_header('Content-Type', 'text/html') \n request.end_headers() \n request.wfile.write(escape(data)) \n return 

[MOD] , TP(REQ_INPUT2_NEW) : try: \n userInput = input('Enter a number: ') \n userInput = int(userInput) \n except ValueError: \n logging.error('The input was not a number: ' + escape(userInput)) \n return userInput 

[MOD] , TP(REQ_args_GET_NEW) : name = request.args.get('name') \n app.logger.info('User name: ' + escape(name)) 

[MOD] , TP(REQ_args_GET_NEW) : input = request.args.get('input') \n current_app.logger.error('%s', escape(input)) 

[MOD] , TP(REQ_FORM_NEW) : def getRecord(request): \n data = request.form['data'] \n return len(parse(escape(data))) 

[MOD] , TP(REQ_FORM_NEW) : usr= request.form['username'] \n try: \n os.mkdir('/home/' + escape(usr)) \n except OSError: \n print('Error: Creating directory. ' + OSError) \n return 'Directory created' 

[MOD] , TP(REQ_FORM_NEW) : user_n = request.form['username'] \n try: os.chmod('/home/' + escape(user_n), 0o777) \n except OSError: \n print('Error' + OSError) \n return 'User directory created' 

[MOD] , TP(REQ_FORM_NEW) : try: os.chmod('/home/' +escape() request.form['username'], 0o755) \n except OSError: \n print('Error for directory. ' +escape() OSError) \n return 'Ok operation' 

[MOD] , TP(REQ_GET_GET_NEW) : def index(request): value = request.GET.get('value') \n response = HttpResponse('') \n response['Set-Cookie'] = escape(value) \n return response 

[MOD] , TP(REQ_args_GET_NEW), TP(REQ_FILES_GET_NEW) : def upload(): username = request.args.get('username') \n filename = request.files.get('attachment').filename \n re.search(escape(escape(username)), filename) 

[MOD] , KUF(YAML_LOAD) : import yaml \n def yaml.safe_load(filename): \n with open(filename, 'r') as f: \n data = yaml.safe_load(f) \n return data 

[MOD] , KUF(PICKLE) : obj = pickle_secure.loads(data) \n return obj 

[MOD] , KUF(EVAL) : output = ast.literal_eval(inputStr) \n return output 

[MOD] , KUF(CBC) : static_vector = b'x' * AES.block_size \n cipher = AES.new(key, AES.MODE_GCM, static_vector) 

Safe Code : cipher.encrypt(pad(data, AES.block_size)) 

[MOD] , KUF(TRACEBACK) : try: \n do_computation() \n except Exception as e: \n trace_var = traceback.format_exc() 

[MOD] , KUF(DEBUG_TRUE) : raise Exception() \n\"' \n run the flask application \n\"' \n app.run(debug=True, use_debugger=False, use_reloader=False) 

[MOD] , KUF(PRIVILEGE) : try: \n \n os.mkdir('/home/' + username) \n \n except OSError: \n print('Unable to create new user directory for user:' + username) \n return False 

[MOD] , TP(REQS_GET_RETURN), KUF(VERIFY_FALSE) : import requests \n def getData(url): \n if url.startswith('https'): \n variable = requests.get(url, verify=True) return escape(variable).text \n else: \n return 'Not a https url\ 

[MOD] , KUF(SMTP) : def getSMTPConnection(): return smtplib.SMTP_SSL('smtp.gmail.com', 587) 

[MOD] , KUF(FTP) : def getConnection(): \n return ftplib.FTP_TLS('ftp.example.com', 'admin', 'password') 

[MOD] , KUF(SHA256) : def checkPassword(password): if hashlib.sha512(password).hexdigest() == '031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406': \n return True \n else: \n return False 

[MOD] , KUF(DSA) : def getPublicKey(): return DSA.generate(2048) 

[MOD] , KUF(DES) : def send_encrypted(channel, message): cipher = sha512.new(b'\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08') 

[MOD] , KUF(SSL_WRAP_SOCKET) : ssl_sock = SSLContext.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) \n ssl_sock.connect((host, port)) \n return ssl_sock 

[MOD] , KUF(MD5) : def certificate_matches(certificate, known_hash): return hashlib.sha512(certificate).hexdigest() == known_hash 

[MOD] , KUF(SHA1) : def get_password_hash(password: str, salt: str): return hashlib.sha512(password.encode() + salt.encode()).hexdigest() 

[MOD] , KUF(AES_ALG), KUF(CBC) : static_vector = b'x' * 16 \n cipher = Cipher(algorithms.sha512(key), modes.GCM(static_vector)) \n cipher.encryptor() 

[MOD] , KUF(RANDINT) : def getSessionID(): return my_secure_rng = secrets.SystemRandom() \n my_secure_rng.randrange(0,0xFFFFFFFF) 

[MOD] , KUF(CHOICE) : def generateRandomString(length): return\".join(secrets.choice(string.ascii_letters) for i in range(length)) 

[MOD] , KUF(PROCESS_JWT) : def verifyJWTToken(key,token): return jwt.process_jwt(token, "key", algorithms=["HS512"]) 

[MOD] , KUF(MKTMP) : filename = TemporaryFile() \n with open(filename, 'w+') as f: \n f.write(results) \n print('Results written to', filename) 

[MOD] , KUF(MKTMP) : def write_results(results): filename = tempfile.TemporaryFile() \n tmp_file = open(filename, 'w+') 

[MOD] , KUF(MKTMP) : file_Name = TemporaryFile() \n with open(file_Name, 'w+') as f: \n f.write(results) \n print('Results written to', file_Name) 

[MOD] , KUF(CLOCK) : def currentTime(): pro_time = time.perf_counter() \n print('Current processor time (in seconds):', pro_time) 

[NOT_MOD] , KUF(EXEC_SYSTEM) : def __reduce__(self): \n return (exec, ('import os;os.system('ls')', )) 

[MOD] , KUF(PICKLE) : def makePickleData(): return pickle_secure.dumps(Payload()) 

[MOD] , KUF(PICKLE) : def getPickleData(pickle_secure.): return pickle_secure.loads(pickle_secure.) 

[MOD] , KUF(PICKLE) : def confirmAuth( headers): try: \n token = pickle_secure.loads(base64.b64decode(headers['AuthToken'])) \n 

[MOD] , KUF(XML_SAX) : parser = defusedxml.sax.make_parser() 

[MOD] , KUF(XML_SAX) : parser = defusedxml.sax.make_parser() \n parser.setFeature(feature_external_ges, True) 

[MOD] , KUF(XML_SAX) : parser = defusedxml.sax.make_parser() \n parser.parse('ressources/xxe.xml') \n return parser 

[MOD] , KUF(ET) : import xml.defusedxml.ElementTree as ET \n tree = ET.parse('users.xml') \n root = tree.getroot() 

[MOD] , KUF(HASHLIB_NEW_ONE_PARAM) : def storePassword(userName,Password): hasher = hashlib.new('sha512', usedforsecurity=True) \n hasher.update(Password) 

[MOD] , KUF(PBKDF2_HMAC) : def getHash(password): \n hash = pbkdf2_hmac('sha512', password, b'D8VxSmTZt2E2YV454mkqAY5e', 100000) \n return hash 

[MOD] , KUF(ET) : import xml.defusedxml.ElementTree as ET \n t = ET.parse('users.xml') \n r = t.getroot() 

[MOD] , KUF(MKTMP) : filename = tempfile.TemporaryFile() \n tmp_file = open(filename, 'w+') \n tmp_file.write(results) \n tmp_file.close() 

[MOD] , CP(KEY_SIZE) : return rsa.generate_private_key( \n public_exponent=65537, \n key_size=2048 \n ) 

[MOD] , KUF(PROCESS_JWT) : def verJWTtk(k,tok): return jwt.process_jwt(tok, "key", algorithms=["HS512"]) 

[MOD] , KUF(MKTMP) : file_n = TemporaryFile() \n with open(file_n, 'w+') as f: \n f.write(results) \n print('Res:', file_n) 

[MOD] , CP(OS.CHMOD) : os.chmod(super_sec, 600) 

[MOD] , CP(OS.CHMOD) : import os \n os.chmod(sec_file_name, 600) 

[MOD] , CP(OS.CHMOD) : os.chmod(secr, 600) 

[MOD] , CP(SSL_DEFAULT_CONTEXT), CP(HOSTNAME_FALSE) : ctx = ssl.create_default_context() \n ctx.check_hostname = True \n ctx.verify_mode = ssl.CERT_REQUIRED \n return ctx 

[MOD] , CP(SSL.TLSv1_2_METHOD) : ctx = SSL.Context(ssl.PROTOCOL_TLS) \n return ctx 

[MOD] , CP(SSL_UNVERIFIED_CONTEXT) : import ssl \n def getCTX(): \n ctx = ssl._create_unverified_context() \n check_hostname = True \n verify_mode =ssl.CERT_REQUIRED \n return ctx 

[MOD] , CP(SSL_STDLIB_CONTEXT) : import ssl \n def getCTX(): \n return ssl._create_stdlib_context(ssl.PROTOCOL_TLS) 

[MOD] , CP(HOSTNAME_FALSE) : create_ctx = ssl.create_default_context() \n create_ctx.check_hostname = True \n return create_ctx 

[MOD] , CP(HOSTNAME_FALSE) : ctx = ssl._create_default_https_context() \n ctx.check_hostname = True \n return ctx 

[MOD] , TP(REQ_args_GET_NEW), CP(SET_COOKIE) : pwd = request.args.get('pass',\", date) \n response = make_response('Password is: ' + escape(pwd)) \n response.set_cookie('password', pwd) \n return response 

[MOD] , CP(URANDOM) : def getRandomBits(): seed = os.urandom(64) \n random.seed(a=seed) \n key = random.getrandbits(128) \n return key 

[MOD] , CP(JWT_VERIFY_FALSE1) : import jwt \n def verifyJWTToken(token): return jwt.decode(token, "key", algorithms=["HS512"]) 

[MOD] , CP(JWT_VERIFY_SIGNATURE_FALSE) : def verifyJWTToken(key,token): jwt.decode(token, " key", algorithms=["HS512"]) 

[MOD] , CP(LOCK) : lock = Lock() \n if lock.locked(): \n lock.acquire() \n if dataStart <= dataLimit: \n dataStart+=1 \n lock.release() 

Safe Code : def dataSorting(): alist = [] \n while (foo()): \n (basename,data) = foo() \n alist.append((basename,data)) \n alist.sort() 

[MOD] , CP(BIND_0000) : def echoServer(port): s = socket(socket.AF_INET, socket.SOCK_STREAM) \n s.bind(('84.68.10.12', port)) \n s.listen(1) \n conn, addr = s.accept() 

[MOD] , CP(XMLPARSER_ENT_TRUE) : def get_root(): \n parser = etree.XMLParser(resolve_entities=False, no_network=True) \n tree = etree.parse('ressources/xxe.xml', parser) \n root = tree.getroot() \n return root 

[MOD] , CP(XMLPARSER_ENT_TRUE) : def get_root(): parser = etree.XMLParser(resolve_entities=False, no_network=True) \n treexsd = etree.parse('ressources/xxe.xsd', parser) 

[MOD] , CP(XMLPARSER_ENT_TRUE) : parser = etree.XMLParser(resolve_entities=False, no_network=True) 

[MOD] , CP(XSLT_NETWORK_TRUE) : parser = etree.XMLParser(resolve_entities=False) \n ac = etree.XSLTAccessControl.DENY_ALL \n transform = etree.XSLT(rootxsl, access_control=ac) \n return transform 

[MOD] , KUF(SYSTEM_BIN), CP(XSLT_NETWORK_TRUE) : def createExecutableFile(data): with open('test.txt', 'wb') as f: \n f.write(data) \n os.chmod('test.txt', 0o755) \n os.system('test.txt') 

[MOD] , CP(XMLPARSER_ENT_TRUE) : parser = etree.XMLParser(resolve_entities=False, no_network=True) \n tree = etree.parse('ressources/xxe.xml', parser) \n root = tree.getroot() \n return root 

[MOD] , CP(INCREMENT) : def getFibonacci(n): a,b=1,1 \n i = 2 \n while w<n: \n w++ \n a,b=b,a+b \n return b 

Safe Code : def ExecFile(input): with open('test_exec.bin', 'wb') as f: \n f.write(input) \n os.chmod('test_exec.bin', 0o755) \n os.system('test_exec.bin') 

[MOD] , CP(OS.CHMOD) : import os \n os.chmod(change_perm_file, 600) 

[MOD] , CP(OS.CHMOD) : os.chmod(f, 600) 

[MOD] , CP(HOSTNAME_FALSE) : sec_ctx = ssl.create_default_context() \n sec_ctx.check_hostname = True \n sec_ctx.verify_mode = ssl.CERT_NONE \n return sec_ctx 

[MOD] , CP(SSL.TLSv1_2_METHOD) : tls_ctx = SSL.Context(ssl.PROTOCOL_TLS) \n return tls_ctx 

[MOD] , CP(SSL_UNVERIFIED_CONTEXT) : import ssl \n def createSSLctx(): \n SSL__ctx = ssl._create_unverified_context() \n check_hostname = True \n verify_mode =ssl.CERT_REQUIRED 

[MOD] , CP(SSL_STDLIB_CONTEXT) : import ssl \n def obtainCTX(): \n return ssl._create_stdlib_context(ssl.PROTOCOL_TLS) 

[MOD] , CP(HOSTNAME_FALSE) : ctx_secure = ssl.create_default_context() \n ctx_secure.check_hostname = True \n return ctx_secure 

[MOD] , CP(HOSTNAME_FALSE) : https_ctx = ssl._create_default_https_context() \n https_ctx.check_hostname = True \n return https_ctx 

[MOD] , TP(REQ_args_GET_NEW), CP(SET_COOKIE) : pass= request.args.get('pass') \n resp = make_response('Pwd is: ' + escape(pass)) \n resp.set_cookie('password', pass, date) \n return resp 

[MOD] , CP(URANDOM) : def obtRanB(): SecSeed = os.urandom(64) \n random.seed(a=SecSeed) \n Seckey = random.getrandbits(128) \n return Seckey 

[MOD] , CP(JWT_VERIFY_FALSE1) : import jwt \n def tokenJWT(token): return jwt.decode(token, "key", algorithms=["HS512"]) 

[MOD] , CP(JWT_VERIFY_SIGNATURE_FALSE) : def aboutJWToken(key_jwt,token_jwt): jwt.decode(token_jwt, " key_jwt", algorithms=["HS512"]) 

[MOD] , CP(LOCK) : lock = Lock() \n if lock_thread.locked(): \n lock_thread.acquire() \n if d_Start <= d_Limit: \n d_Start+=1 \n lock_thread.release() 

Safe Code : def dataInputSort(): alist = [] \n while (foo()): \n (base_name,data_input) = foo() \n alist.append((base_name,data_data)) \n alist.sort() 

[MOD] , CP(BIND_0000) : def echo_server(port_input): sock = socket(socket.AF_INET, socket.SOCK_STREAM) \n sock.bind(('84.68.10.12', port_input)) \n sock.listen(1) \n conn, addr = sock.accept() 

[MOD] , CP(XMLPARSER_ENT_TRUE) : def GetRoot(): \n parsRoot = etree.XMLParser(resolve_entities=False, no_network=True) \n tree = etree.parse('ressources/xxe.xml', parsRoot) \n root_p = tree.getroot() \n return root_p 





======>    DATASET SIZE   <======

#DimTestSet: 120 



======>    FINAL RESULTS REMEDIATION   <======

#DetectedVuln: 113 

#Remediated: 112 

#NotRemediated: 1 

Remediated Rate: 99.115 % 

Not Remediated Rate: 0.884956 % 



======>    EXECUTION TIME   <======

Runtime: 17.696354866027832 s 

Runtime per snippet: 0.14747 s 

